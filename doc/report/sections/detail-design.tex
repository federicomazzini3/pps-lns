\section{Design di dettaglio}
Design di dettaglio (scelte rilevanti, pattern di progettazione, organizzazione del codice -- corredato da pochi ma efficaci diagrammi)
Di seguito verranno analizzate le scelte di design rilevanti per il sistema, i pattern di progettazione utilizzati e l'organizzazione del codice. 
\subsection{GameModel}
L'intero modello di gioco, dallo stato al comportamento, è incapsulato all'interno della struttura GameModel. E' possibile identificare due diverse accezioni del modello, a seconda del momento di gioco. 
Un momento in cui la partita non è ancora stata avviata e un momento successivo in cui invece la partita è avviata.
Nel primo momento, a partita non avviata, è necessario generare il dungeon e le stanze che lo compongono. Nel secondo momento, una volta che è avvenuta la generazione, il modello è costituito da un Dungeon, composto da diverse stanze, e dal character controllato dal giocatore. 

\begin{figure}[!hbt]
    \centering
    \includegraphics[scale=0.2]{GameModelClassDiagram.jpg}
    \caption{\textit{Game model class diagram (da modificare con versione pro di staruml)}} 
\end{figure}
Il modello di gioco rappresenta un'istantanea delle varie componenti che lo compongono in un determinato momento. 
Ogni modifica al modello consiste nella creazione di un nuovo modello con il componente aggiornato. 

Una scelta rilevante ai fini dell'implementazione è il fatto che, a livello di modello, il character controllato dal giocatore è sempre fuori dalla stanza in cui si trova, in questo modo è possibile aggiornare in maniera indipendente le due componenti.
\subsection{Dungeon}
Dungeon è il termine con cui viene identificata la mappa di gioco. Esso è composto da stanze disposte in maniera randomica ma collegate tra loro. 
La struttura Grid è ciò che descrive un Dungeon nella sua forma più basilare e geometrica e offre delle operazioni per esplorarlo. 
\begin{figure}[!hbt]
    \centering
    \includegraphics[scale=0.2]{DungeonClassDiagram.jpg}
    \caption{\textit{Dungeon class diagram(da modificare con versione pro di staruml)}} 
\end{figure}

Grid definisce quindi una collezione di stanze, di tipo ancora non definito, in una specifica posizione all'interno di una griglia di dimensioni \textit{n}. All'interno di una griglia, un elemento potrebbe o non potrebbe essere presente, andando così a definire un dungeon con stanze in posizioni diverse. E' necessario perciò lavorare con strutture dati che consentano l'assenza di un dato.

Il Dungeon vero e proprio prende forma quando il tipo Room viene definito con un modello consono a descriverne lo stato e il comportamento. 

\subsection{Room}
Come da requisiti, una stanza è la componente principale del Dungeon e può essere di diversi tipi: Empty, Arena, Item e Boss. 
Ogni stanza incapsula al suo interno gli elementi che sono rilegati all'interno e non possono muoversi all'interno del Dungeon, come ad esempio i nemici o gli elementi bloccanti. 

\begin{figure}[!hbt]
    \centering
    \includegraphics[scale=0.25]{RoomClassDiagram.jpg}
    \caption{\textit{Room class diagram(da modificare con versione pro di staruml)}} 
\end{figure}

Una stanza è anche responsabile dell'aggiornamento di tutto ciò che incapsula. Anche in questo caso si cerca di lavorare con strutture dati immutabili, perciò l'aggiornamento di uno o più componenti consegue una nuova stanza aggiornata. 
L'aggiornamento viene fatto ad ogni FrameTick ed è comandato dal dungeon, solamente per la stanza correntemente visualizzata, le altre stanze non sono aggiornate o gestite.  

\subsubsection{Door}
Un dettaglio importante di una stanza sono le porte che la collegano con altre stanze. Si è scelto di definire una porta non tanto come un link, ma come una proprietà statica, lasciando al Dungeon il compito di gestire il collegamento. 
Una porta è quindi l'associazione di un lato della stanza con lo stato della stessa. Il fatto che vi sia una porta, presuppone comunque che dalla parte opposta vi sia un'altra stanza, ma questo dettaglio è trasparente alla stanza e gestita dal Dungeon. 
\begin{figure}[!hbt]
    \centering
    \includegraphics[scale=0.25]{DoorClassDiagram.jpg}
    \caption{\textit{Door class diagram(da modificare con versione pro di staruml)}} 
\end{figure}

\subsection{AnythingModel}
In generale ogni oggetto in gioco contiene un identificativo univoco e una bounding box che ne determina posizione e dimensioni 2D, inoltre ad ogni istanza è associata la factory per la sua View in modo tale che, quando una collezione di AnythingModel viene renderizzata, è sufficiente creare la View e chiamare il metodo draw. 

Ogni oggetto inoltre reagisce alla richiesta di update che avviene ad ogni iterazione del game loop, ma il modo con cui lo fa dipende da specifici comportamenti definiti come sottotipi mixabili di AnythingModel.

I sottotipi principali sono:
\begin{itemize}
    \item \textbf{DynamicModel} un oggetto in grado di spostarsi autonomamente durante un update, dove e come viene stabilito dalla classe che esegue il mixing
    \item \textbf{AliveModel} un oggetto vivo che può essere colpito perdendo vita. Non ha comportamento autonomo.
    \item \textbf{DamageModel} un oggetto che provoca danno di contatto. Non ha comportamento autonomo.
    \item \textbf{FireModel} un oggetto in grado di sparare autonomamente durante un update, dove e come viene stabilito dalla classe che esegue il mixing. Durante l'update può emettere uno ShotEvent contenente ShotModel
    \item \textbf{SolidModel} un oggetto solido che non può essere fisicamente attraversato da un altro. Non ha comportamento autonomo.
\end{itemize}

Questi tratti possono richiedere delle Stats per ottenere dei parametri al loro funzionamento (ad esempio la velocità massima da applicare ad uno spostamento): le Stats se richieste sono assegnate durante l'istanzazione di un Model ma possono cambiare durante il gioco.

Di seguito in figura 10 mostriamo un estratto della gerarchia di AnythingModel con tutti i sottotipi che aggiungono proprietà e comportamenti al Model di base e che possono essere estesi o mixati da un Model finale.

\begin{figure}[!hbt]
    \centering
    \includegraphics[scale=0.35]{AnythingModel.jpg}
    \caption{\textit{Gerarchia AnythingModel}} 
\end{figure}

\subsubsection{Update e immutabilità}

Ogni metodo che aggiorna il Model, a partire da update che viene richiamata ad ogni iterazione del game loop, deve ritornare una copia aggiornata dello stesso. 


\subsection{Pattern di progettazione}
Di seguito si elencano brevemente i pattern di progettazione utilizzati. 
\subsubsection{Family polimorphism}
Il family polimorphism è stato utilizzato in più di un occasione, tra cui
\begin{itemize}
    \item Definizione di una struttura per il Dungeon, ancora da tipare, ma che già definisce i comportamenti principali di esso.
\end{itemize}
\subsubsection{Bounded F-polimorphism}
\subsubsection{Pimp my library}
Il pattern Pimp my library è stato ampiamente utilizzato, soprattuto per quanto riguarda l'estensione di librerie scritte da terze parti, come ad esempio l'engine Indigo. 
Avendo usato Scala 3 è stato utilizzato il meccanismo degli \textit{extension} method.

In particolare è stata estesa la struttura dati Group di Indigo (rappresentante un gruppo di elementi visualizzabili a schermo), aggiungendo metodi comuni per centrare e scalare gli oggetti in base allo schermo.

Si è sfruttato il pattern anche per modellare le Door come solo struttura dati, per poi modellare i vari comportamenti mediante metodi esterni. Per questa struttura, si è quindi diviso lo stato dal comportamento. 

...andare avanti

\subsubsection{Strategy}
Il pattern strategy è stato utilizzato all'interno della logica di update delle strutture dati. Avendo lavorato con strutture dati immutabili, è stato molto utile definire una funzione comune di aggiornamento che accettasse una strategia di aggiornamento piuttosto che il vero aggiornamento, per via delle logiche a volte innestate che ci si è trovati ad affrontare. 
Un altro momento in cui si è rivelato utile questo pattern è stato all'interno del sistema di gestione delle collisioni, in cui, alla scoperta di una collisione, l'update dell'elemento dipendeva appunto da una strategia variabile. 
\subsubsection{Adapter}
Conversion

\subsection{Organizzazione del codice}
Il codice è stato organizzato in packages. Questi seguono la suddivisione in scene dell'applicativo. Al loro interno, si può ritrovare una suddivisione in Model, View, ViewModel e Componenti.
Il package Core invece, contiene le parti basilari a cui il resto del sistema fa riferimento.

\begin{figure}[!hbt]
    \centering
    \includegraphics[scale=0.25]{package-diagram.jpg}
    \caption{\textit{Package Diagram del sistema(da modificare con versione pro di staruml)}} 
\end{figure}